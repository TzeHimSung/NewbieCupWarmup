# 热身赛题解

## A. 国士无双

题意：  

> 给定一个字符串，判断该字符串是否仅由1m、9m、1p、9p、1s、9s、1z、2z、3z、4z、5z、6z、7z子串组成。若无缺失子串，全部输出；否则输出缺失子串。  

一道有点细节的模拟题，因为输入已经保证字符串长度为26(即给13张牌)，细心点就好了。考虑以下三点：  
1. 手牌中是否包含`非幺九牌`  。
2. 有且只有一种情况，手牌能形成`十三面听`(十三种幺九牌全为听牌)：每种幺九牌均出现在手牌中。    
3. `单吊`(只听一张牌)时，手牌中幺九牌的种类只可能为十二种。  

按以上思路，依次检查手牌即可，详见[标程](https://github.com/TzeHimSung/NewbieCupWarmup/blob/main/A/std.cpp)。  

## B. ONU!

非常无聊的模拟题，以至于题解根本不知道该写什么，直接模拟一遍游戏过程就可以了。 

主要问题在于如何优雅地维护玩家卡组信息。[标程](https://github.com/TzeHimSung/NewbieCupWarmup/blob/main/B/std.cpp)提供了一种借助`struct`和`map`维护的方法，仅供参考。 

## C. 好多表达式

对于每一位数字，只有两种操作：  

1. 在这个数字前面放`+`号  。
2. 不在这个数字前面放`+`号  。

于是考虑dfs。在搜索过程中，我们需要维护以下信息：  

1. **表达式中已经固定下来的数字**，可以用一个`数组`（或者`vector`、`stack`之类的数据结构）去维护。  
2. **正在构造中的数字**，用一个`int`类型变量维护即可。  
3. **遍历到数字第几位**，用一个`int`类型变量维护即可。  

每次遍历完数字，表达式和即为`数组和`+`构造中数字`之和。 

这种方式会将每条表达式构造两次，所以不要忘记除 $2$，详见[标程](https://github.com/TzeHimSung/NewbieCupWarmup/blob/main/C/std.cpp)。  

## D. 排名之谜

非常有趣的思维题，最好排名为 $max(1, min(n, x + y + 1 - n))$ ，最坏排名为 $min(x + y - 1, n)$ ​。 

这里提供两种思路，仅作参考。  

### Solution 1. 打表

只凭肉眼、弱样例和手动构造样例，难以观察 $n$ 、 $x$ 、 $y$ 与答案的关系。不妨考虑**打表**，枚举`JHSeng`第1、2轮所有的排名，计算所有可能的最好排名与最坏排名。   
打表代码见[此处](https://github.com/TzeHimSung/NewbieCupWarmup/blob/main/D/bruteforce.cpp) 。  
这份代码的执行效率比较低， $n=6$ 时要跑比较久的时间。这里有一份更好的打表[实现](https://github.com/TzeHimSung/NewbieCupWarmup/blob/main/D/bruteforce2.cpp)，利用`STL`的`next_permutaion`优化了写法，仅供参考。  
打表代码的运行结果如下：

```shell
best rank result
1 1 1 1 2 
1 1 1 2 3 
1 1 2 3 4 
1 2 3 4 5 
2 3 4 5 5 
worst rank result 
1 2 3 4 5 
2 3 4 5 5 
3 4 5 5 5 
4 5 5 5 5 
5 5 5 5 5
```
最坏排名的规律显而易见，就是 $x+y-1$ ，再与总人数取较小值。 
最好排名的规律其实也不难猜测。通过矩阵中的2、3、4的值与它们所在的下标可以看出是 $x+y-n+1$ ，再保证答案落入 $[1, n]$ 的区间，修正上述公式的不合理值即可。  

### Solution 2. 构造

我们先考虑最坏总排名。注意到`总排名`的定义：`得分小于或等于当前参赛者分数的人数（包括参赛者本人）`。 

也就是说，如果我们希望`JHSeng`的排名尽可能差，那么只需要尽可能多地构造跟`JHSeng`得分相同的人即可（不需要比他小，因为得到的效果是相同的，都会让`JHSeng`的排名往后靠）。 

所以问题转化为：如何使得尽量多的人，分数为 $x+y$ 。 

假设第一轮排名是升序的，满足 $1, 2, ..., n$ 的形式。如果要让所有人的分数都为 $x+y$ ，理想情况下，第二轮排名的形式为 $x+y-1, x+y-2, ..., 2, 1$ 。这样使得前 $x+y-1$ 个人的得分为 $x+y$ ​​。 

注意到这里的排名有可能不合法（比 $n$ 大），所以要与 $n$ 取`min`，得到 $min(n, x+y-1)$ 的推断结果。 

再考虑最好总排名，也就是让得分大于 $x+y$ 的人尽可能多。这里需要分类讨论。  

1. 若 $x+y \le n$ ，那么让所有人得分为 $n+1$ 即可。令第一轮排名为 $1, 2, ..., n$ ，第二轮排名为 $n, n-1, n-2, ..., 1$ ，这种构造方式显然满足条件。由于 $x+y \le n$ ​，所以`JHSeng`必在第一名。

2. 若 $x+y \gt n$ ，这种情况不能保证`JHSeng`在第一名，**因为第一种情况的构造方式变得不可用了**。那么，我们就想办法让第一名“剔除”出游戏。

   “剔除”的方式很简单：让第一名的两轮排名尽可能小。此时我们可以忽略第一名的存在，让游戏规模从 $n$ 名参赛者变成 $n-1$ 名参赛者。此时 $x$ 会变成 $x-1$ ， $y$ 会变成 $y-1$ 。

   这个“剔除”的过程要重复若干次，直到 $x+y \le n$ 再次成立。假设重复 $t$ 次，在边界条件 $x+y=n$ 时，显然有下式成立：

$$
  x-t+y-t=n-t
$$

​	解得： 

$$
t=x+y-n
$$


​	也就是说会有 $x+y-n$ 个人会在`JHSeng`前面，最好排名自然就是 $x+y-n+1$ 。 别忘了修正答案，让它落入`[1, n]`的区间，得到 $max(1, min(n, x + y + 1 - n))$ 这个结果。

## E. 有内鬼，停止交易!

题意：

> 输出任意满足 $a \bigoplus b = n$ 的 质数 $a$ 与 合数 $b$ （ $2 \leq a,b \leq  2\times 10^{18}$ ）

注意：1既不是质数也不是合数！

### Solution 1. 构造

对于任何一个数字的二进制表示，我们知道他的最后一位必然是 $0$ 或者 $1$ ，同时我们必然可以确认所有大于2的偶数都是合数。因此，我们只需要操纵 $n$ 的最后一个二进制位，使其变为0即可构造出一个合数。同时我们已知 $2$ 和 $3$ 都是质数，因此我们只需要让奇数输出 $3$ 和 $n \bigoplus 3$ ，偶数输出 $2$ 和 $n \bigoplus 2$ 即可，这样可以实现第二个数总是偶数。
同时我们发现小于4的数字可能存在一些问题，例如出现第一个数为 $0$ 或 $2$ ，因此 $n$ 小于4的时候需要特判。
我们手动枚举，即可得到一些答案，例如下面的结论：

- $n=1$ 时，令 $a=7$ ， $b=6$
- $n=2$ 时，令 $a=11$ ， $b=9$
- $n=3$ 时，令 $a=7$ ， $b=4$

详见[标程](https://github.com/TzeHimSung/NewbieCupWarmup/blob/main/E/std.cpp)。
py代码详见[标程](https://github.com/TzeHimSung/NewbieCupWarmup/blob/main/E/std.py)。
### Solution 2. 枚举
观察方法一，我们发现，任何一个数总有一个很小的质数 $b$ 使得答案成立，因此从小到大枚举从 $2$ 到 $2n$ 的质数，枚举若干个就能得出答案了（至多 $10$ 个），且本题并没有严格限制时间，每个 $n$ 可以枚举约100个质数都不会超时，在此不再赘述。
